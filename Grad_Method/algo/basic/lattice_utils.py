import numpy as np
from fpylll import * 
import matplotlib.pyplot as plt
from tqdm import tqdm
from itertools import combinations

def URAN(n):
    '''
    Generate n random real numbers uniformly distributed in [0, 1) and  independent of each other.
    Use PCG64 to generate random real numbers.

    :param n: int, the number of random real numbers to generate
    :return: np.array, shape=(n, ), the generated random real numbers
    '''
    return np.random.default_rng().uniform(0, 1, n)

def GRAN(n, m):
    '''
    Generate n*m matrix of random independent real numbers
    each with a Gaussian zero-mean, unit-variance distribution.
    Generating them usnig Box-Muller method.
    
    :param n: int, the number of rows of the matrix
    :param m: int, the number of columns of the matrix
    :return: np.array, shape=(n, m), the generated matrix
    '''
    generator = np.random.default_rng()
    U = generator.normal(0, 1, (n, m))
    return U

def CLP(B, x):
    '''
    Find the point in the lattice generated by B that is closest to x.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :param x: np.array, shape=(n, ), the point to be quantized
    :return: np.array, shape=(n, ), the integer coordinates of the point in the lattice closest to x
    '''

    '''a numerically unstable way to find the closest point in the lattice
    fpylll only support integer matrix, so we need to convert the input to integer matrix by multiplying a large number, which may results in numerical instability'''

    scale = 10000   
    scaled_B = B * scale
    scaled_x = x * scale
    scaled_B = scaled_B.astype(int)
    scaled_B = scaled_B.tolist()
    scaled_x = scaled_x.astype(int)
    scaled_x = scaled_x.tolist()
    A = IntegerMatrix.from_matrix(scaled_B)
    b = scaled_x
    cvp = CVP.closest_vector(A, b)
    return np.rint(np.dot(cvp, np.linalg.inv(scaled_B)))



def new_CLP(G_tmp, r_tmp): 

    # the orginal code in paper index start from 1
    # so we need to convert the index to start from 0

    G = np.zeros((np.shape(G_tmp)[0]+1, np.shape(G_tmp)[1]+1))
    G[1:, 1:] = G_tmp.copy()
    r = np.zeros(np.shape(r_tmp)[0]+1)
    r[1:] = r_tmp.copy()


    C = np.inf
    n = np.shape(G)[0] - 1
    i = n + 1
    d = np.zeros(n+1, dtype=int)
    for j in range(1, n+1, 1):
        d[j] = n
    lambda_ = np.zeros(n+2)
    F = np.zeros((n+1, n+1))
    F[n, 1:] = r[1:]
    u = np.zeros(n+1)
    p = np.zeros(n+1)
    delta = np.zeros(n+1)

    def my_sign(x):
        if x <= 0:
            return -1
        return 1
    
    while True:
        flag1 = False
        while not flag1 or lambda_[i] < C:
            # print("first loop") 
            flag1 = True
            if i != 1:
                i -= 1
                for j in range(d[i], i, -1):
                    F[j-1, i] = F[j, i] - u[j]*G[j, i]
                p[i] = F[i, i] / G[i, i]
                u[i] = np.rint(p[i])
                y = (p[i] - u[i]) * G[i, i]
                delta[i] = my_sign(y)
                lambda_[i] = lambda_[i+1] + y**2
            else:
                u_ = u[1:]
                C = lambda_[1]

        m = i
        flag2 = False
        while not flag2 or lambda_[i] >= C:
            # print("second loop")
            flag2 = True
            if i == n:
                return u_
            else:
                i += 1
                u[i] = u[i] + delta[i]
                delta[i] = -delta[i] - my_sign(delta[i])
                y = (p[i] - u[i]) * G[i, i]
                lambda_[i] = lambda_[i+1] + y**2

        for j in range(m, i, 1):
            d[j] = i
        for j in range(m-1, 0, -1):
            if d[j] < i:
                d[j] = i
            else:
                break

    
def RED(B):
    '''
    Return another generator matrix for the lattice generated by B
    in which the rows are shorter and more orthogonal.
    Use Lenstra-Lenstra-Lovasz algorithm.
    If no improved generator matrix can be found, return B.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :return: np.array, shape=(n, n), the new generator matrix
    '''
    def orthogonal(m):
        n = np.shape(m)
        M = np.zeros(n, dtype=np.float64)
        n = n[0]
        M[0, :] = m[0, :]
        for i in range(1, n):
            M[i, :] = m[i, :]
            for j in range(0, i):
                u_ij = np.dot(m[i, :], M[j, :]) / (np.linalg.norm(M[j, :]) ** 2)
                M[i, :] -= u_ij * M[j, :]
        return M


    def lll(v):
        n = np.shape(v)
        n = n[0]
        k = 2
        while k <= n:
            V = orthogonal(v[0:k, :])
            for j in range(0, k-1):
                u = np.dot(v[k - 1, :], V[j, :]) / (np.linalg.norm(V[j, :]) ** 2)
                v[k - 1, :] = v[k - 1, :] - np.round(u) * v[j, :]
            u = np.dot(v[k - 1, :], V[k - 2, :]) / (np.linalg.norm(V[k - 2, :]) ** 2)
            if np.linalg.norm(V[k - 1, :]) ** 2 >= (3 / 4 - (u ** 2)) * (np.linalg.norm(V[k - 2, :]) ** 2):
                k += 1
            else:
                v[[k-2,k-1],:] = v[[k-1,k-2],:] 
                k = max(k - 1, 2)
        return v

    return lll(B)

    # use fpylll to reduce the basis
    # convert B from np.int64 to int
    # C = B.tolist()
    # A = IntegerMatrix.from_matrix(C)
    # red = LLL.reduction(A)
    # np_array = np.array([list(row) for row in red])
    # return np_array

def ORTH(B):
    '''
    Rotate and Reflect an arbitrary generator matrix into 
    a square, lower-triangular generator matrix with positive diagonal elements.
    Cholesky-decompose the Gram matrix A = BB^T.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :return: np.array, shape=(n, n), the new geserator matrix
    '''
    return np.linalg.cholesky(B @ B.T)
    # return np.linalg.cholesky(B)

def visualize_lattice(B):
    '''
    Visualize the lattice generated by B.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    '''
    n = np.shape(B)
    n = n[0]
    if n == 2:
        # plot the lattice generated by B
        # we plot the integer coordinates in the range [-10, 10] for each dimension
        points = []
        for i in range(-10, 11):
            for j in range(-10, 11):
                coord = np.array([i, j])
                points.append(np.dot(coord, B))
        
        points = np.array(points)

        plt.scatter(points[:, 0], points[:, 1], s=1, c='blue')
        plt.axhline(0, color='black', lw=0.5)
        plt.axvline(0, color='black', lw=0.5)
        plt.show()

    else:
        print("The dimension of the lattice is not 2, cannot visualize the lattice.")

def estimate_NSM(B, T=100000):
    '''
    Estimate the normalized second moment of the lattice generated by B.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :return: float, the mean and variance of the estimated NSM
    '''
    def estimate_G(B):
        n = np.shape(B)[0]
        z = URAN(n)
        u = CLP(B, np.dot(z, B))
        e = np.dot(z-u, B)
        G = 1/n * np.linalg.det(B)**(-2/n) * np.linalg.norm(e)**2
        return G
    
    mean_sum= 0
    var_sum = 0
    for i in tqdm(range(T)):
        tmp = estimate_G(B)
        mean_sum+= tmp
        var_sum+= tmp*tmp
    mean = mean_sum/T
    var = 1/(T-1) * (1/T * var_sum - mean**2)
    return mean, var

def theta_image(B_const):
    '''visualize lattice by theta image.
    Theata image:
        - horizontal axis: r^2, the squared distance from the origin
        - vertical axis: number of lattice points within the distance r from the origin
        
    :param B: np.array, shape=(n, n), the basis of the lattice
    '''

    B = B_const.copy()
    n = np.shape(B)[0][0]

    # pemuatation of integer coordinates for dimension n
    def permute(n):
        if n == 1:
            return [[1], [-1]]
        else:
            res = []
            for p in permute(n-1):
                res.append(p + [1])
                res.append(p + [-1])
            return res


    