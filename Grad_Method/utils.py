import numpy as np

def URAN(n):
    '''
    Generate n random real numbers uniformly distributed in [0, 1) and  independent of each other.
    Use PCG64 to generate random real numbers.

    :param n: int, the number of random real numbers to generate
    :return: np.array, shape=(n, ), the generated random real numbers
    '''
    return np.random.default_rng().uniform(0, 1, n)

def GRAN(n, m):
    '''
    Generate n*m matrix of random independent real numbers
    each with a Gaussian zero-mean, unit-variance distribution.
    Generating them usnig Box-Muller method.
    
    :param n: int, the number of rows of the matrix
    :param m: int, the number of columns of the matrix
    :return: np.array, shape=(n, m), the generated matrix
    '''
    generator = np.random.default_rng()
    U = generator.normal(0, 1, (n, m))
    return U

def CLP(B, x):
    '''
    Find the point in the lattice generated by B that is closest to x.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :param x: np.array, shape=(n, ), the point to be quantized
    :return: np.array, shape=(n, ), the integer coordinates of the point in the lattice closest to x
    '''
    # TODO: implement this function
    pass

def RED(B):
    '''
    Return another generator matrix for the lattice generated by B
    in which the rows are shorter and more orthogonal.
    Use Lenstra-Lenstra-Lovasz algorithm.
    If no improved generator matrix can be found, return B.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :return: np.array, shape=(n, n), the new generator matrix
    '''
    def orthogonal(m):
        n = np.shape(m)
        M = np.zeros(n, dtype=np.float64)
        n = n[0]
        M[0, :] = m[0, :]
        for i in range(1, n):
            M[i, :] = m[i, :]
            for j in range(0, i):
                u_ij = np.dot(m[i, :], M[j, :]) / (np.linalg.norm(M[j, :]) ** 2)
                M[i, :] -= u_ij * M[j, :]
        return M


    def lll(v):
        n = np.shape(v)
        n = n[0]
        k = 2
        while k <= n:
            print(k)
            V = orthogonal(v[0:k, :])
            for j in range(0, k-1):
                u = np.dot(v[k - 1, :], V[j, :]) / (np.linalg.norm(V[j, :]) ** 2)
                v[k - 1, :] = v[k - 1, :] - np.round(u) * v[j, :]
            u = np.dot(v[k - 1, :], V[k - 2, :]) / (np.linalg.norm(V[k - 2, :]) ** 2)
            if np.linalg.norm(V[k - 1, :]) ** 2 >= (3 / 4 - (u ** 2)) * (np.linalg.norm(V[k - 2, :]) ** 2):
                k += 1
            else:
                v[[k-2,k-1],:] = v[[k-1,k-2],:] 
                k = max(k - 1, 2)
        return v

    return lll(B)



def ORTH(B):
    '''
    Rotate and Reflect an arbitrary generator matrix into 
    a square, lower-triangular generator matrix with positive diagonal elements.
    Cholesky-decompose the Gram matrix A = BB^T.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :return: np.array, shape=(n, n), the new geserator matrix
    '''
    return np.linalg.cholesky(B @ B.T)
    # return np.linalg.cholesky(B)

