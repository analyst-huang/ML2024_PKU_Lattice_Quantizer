import numpy as np
from fpylll import IntegerMatrix, Vector, CVP

def URAN(n):
    '''
    Generate n random real numbers uniformly distributed in [0, 1) and  independent of each other.
    Use PCG64 to generate random real numbers.

    :param n: int, the number of random real numbers to generate
    :return: np.array, shape=(n, ), the generated random real numbers
    '''
    return np.random.default_rng().uniform(0, 1, n)

def GRAN(n, m):
    '''
    Generate n*m matrix of random independent real numbers
    each with a Gaussian zero-mean, unit-variance distribution.
    Generating them usnig Box-Muller method.
    
    :param n: int, the number of rows of the matrix
    :param m: int, the number of columns of the matrix
    :return: np.array, shape=(n, m), the generated matrix
    '''
    generator = np.random.default_rng()
    U = generator.normal(0, 1, (n, m))
    return U

def CLP(B, x):
    '''
    Find the point in the lattice generated by B that is closest to x.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :param x: np.array, shape=(n, ), the point to be quantized
    :return: np.array, shape=(n, ), the integer coordinates of the point in the lattice closest to x
    '''
    B_fpylll = IntegerMatrix.from_matrix(B.tolist())
    x_fpylll = Vector(x.tolist())
    v = CVP.closest_vector(B_fpylll, x_fpylll)
    return np.array(v)
    # TODO: implement this function
    pass

def RED(B):
    '''
    Return another generator matrix for the lattice generated by B
    in which the rows are shorter and more orthogonal.
    Use Lenstra-Lenstra-Lovasz algorithm.
    If no improved generator matrix can be found, return B.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :return: np.array, shape=(n, n), the new generator matrix
    '''
    # TODO: implement this function
    pass

def ORTH(B):
    '''
    Rotate and Reflect an arbitrary generator matrix into 
    a square, lower-triangular generator matrix with positive diagonal elements.
    Cholesky-decompose the Gram matrix A = BB^T.
    
    :param B: np.array, shape=(n, n), the basis of the lattice
    :return: np.array, shape=(n, n), the new geserator matrix
    '''
    # TODO: implement this function
    pass

